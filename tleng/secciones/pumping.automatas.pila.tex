\section{Lenguajes regulares y lema de pumping}
\label{sec:pumping}
\subsection{Lema de pumping}
\label{subsec:pumping}
\paragraph{Propiedad:} Sea \(\mathcal{L}\) un lenguaje regular, si las longitudes de las cadenas de un lenguaje \(\mathcal{L}\) están acotadas superiormente, entonces \(\mathcal{L}\) tiene que ser finito.

\paragraph{Propiedad:} Si \(\mathcal{L}\) es un luenguaje regular infinito, entonces el grafo de un autómata fínito que acepte \(\mathcal{L}\) tiene que tener un camino desde el estado inicial hasta algún estado final que paso por algún ciclo.

\paragraph{Lema de pumping:} Sea \(\mathcal{L}\) un lenguaje regular, si \(\mathcal{L}\) es infinito, entonces todas las cadenas \(\omega\) de longitud mayor o igual a \(n\) (para algún \(n > 1\)) van a ser de la forma \(\omega=xy^iz\), estext decir hay una parte de \(\omega\) que se repite \(i\) cantidad de veces:

\begin{align*}
   & \mathcal{L} \text{ es regular e infinito}\implies \exists n\in\mathbb{N}\text{ tal que } \\ &\forall\omega\in\mathcal{L},~|\omega|\geq n:\left( \exists x,y,z\in\Sigma^*: \omega=xyz\land|xy|\leq n\land|z|\geq 1 \land (\forall i\geq  0 :~ xy^iz\in\mathcal{L}\right) \\
\end{align*}
\begin{demo}[0.8\textwidth]  Supongamos que \(\mathcal{L}\) es un lenguaje regular. Entonces existe una AFD \(A =\langle Q, \Sigma, \delta, q_0, F\rangle\) que acepta \(\mathcal{L}\).

  Sea \(n = |Q|\) la cantidad de estados de \(A\) y \(\omega=a_1a_2\dots a_m\in\Sigma^*\) de longitud \(m > n\). Para cada \(i = 0,\dots, m\) definamos el estado \(p_i = \hat\delta(q_0, a_1\dots a_i)\) (el estado en el que se encuentra \(A\) después de haber consumido los primeros \(i\) símbolos de \(\omega\).

  Como el \(A\) solo tiene \(n\) estados pero hay \(m > n\) estados \(p\), poes imposible que todos los \(p\) sean distintos. Por lo tanto, existen \(0 \leq i < j \leq n\) tales que \(p_i = p_j\).

  Considerar entonces la siguiente descomposición para \(\omega = xyz\):
  \begin{itemize}
    \item[] \(x = a_1\dots a_i\)
    \item[] \(y = a_{i+1}\dots a_j\)
    \item[] \(z = a_{j+1}\dots a_m\)
  \end{itemize}
  Entonces podemos concluir que:
  \begin{itemize}
    \item[] \(\hat\delta(q_0, x) = p_j\)
    \item[] \(\hat\delta(p_i, y) = p_j\) (que como son el mismo estado implica que \(A\) tiene un ciclo)
    \item[] \(\hat\delta(p_j, z) = p_m\)
  \end{itemize}

\end{demo}
\begin{demoPart}[0.8\textwidth]

  Observar que \(x\) podría ser la cadena cuando \(i = 0\), \(z\) podría ser vacía si \(j = n = m\), pero \(y\) no puede ser vacía ya que se tomó \(i < j\).

  Vimos entonces que si \(\mathcal{L}\) es regular y \(|\omega| \geq n\) entonces podemos dividirla en cadenas \(x,y,z\) tal que \(|xy|\leq n\) y \(|z|\geq 1\). Ahora vamos a ver que si \(xyz \in \mathcal{L}\) entonces \(xy^kz \in \mathcal{L}\) para todo \(k\geq 0\).

  \begin{itemize}
    \item Si \(k = 0\) entonces \(xy^0z = xz\):
          \[\hat\delta(q_0, xz) = \hat\delta(\hat\delta(q_0, x), z) = \hat\delta(p_i, z) = \hat\delta(p_j, z) = p_m\]
          Y \(p_m\) es un estado final pues es el mismo estado al que llegamos si la entrada fuese \(xyz\in\mathcal{L}\). Entonces \(xz = xy^0z \in \mathcal{L}\).
    \item Si \(i > 0\). Entonces \(A\) consume \(x\) desde \(q_0\) y llega hasta \(p_i\). Luego \(A\) consume \(y\) desde \(p_i\) y llega hasta \(p_j\) (que son iguales) y repite este ciclo \(k\) veces hasta consumir todas las apariciones de \(y\) en la cadena. Finalmente \(A\) consume \(z\) desde \(p_j\) y llega hasta \(p_m\). Entonces \(A\) llega a un estado final y por lo tanto \(xy^kz \in \mathcal{L}\).
  \end{itemize}
\end{demoPart}
\paragraph{Contrarecíproco:}
\begin{align*}
   & \forall   n\in\mathbb{N}  \exists\omega\in\mathcal{L}\text{ tal que } |\omega|\geq n \land  \forall x,y,z\in\Sigma^*: \omega\neq xyz \land|xy|\geq n\lor|z|\leq 1 \lor \exists i\geq 0,~ xy^iz\notin\mathcal{L} \\ &
  \implies \mathcal{L}\text{  no es regular}                                                                                                                                                                         \\
\end{align*}